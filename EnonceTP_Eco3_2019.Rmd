# Chargement de la base de données et exploration
```{r, eval=FALSE}
library(tidyverse)
```
## Chargement de la base
La base est une extraction de la moitié des ménages...
```{r echo=TRUE}
load("allgre.PB_V2.RData")
table(allgre.PB_V2$nbd)
# Verif des NO_DEPL
table(allgre.PB_V2$NO_DEPL)
# Vérif_id_depl
table(is.na(allgre.PB_V2$id_depl))
# Nouveau id_depl
allgre.PB_V2$id_depl <- allgre.PB_V2$id_pers * 10  + allgre.PB_V2$NO_DEPL 
table(is.na(allgre.PB_V2$id_depl))
table(allgre.PB_V2$nbd)
```



## Description du contenu de la base de données


```{r}
Ncol <- 7; 
v <- Ncol* (Nlin <-  ceiling(length(names(allgre.PB_V2))/Ncol )) - length(names(allgre.PB_V2))
mat <- matrix(c(names(allgre.PB_V2), rep("",v)), ncol = Ncol, 
              dimnames = list(1:Nlin,c("col1", "col2", "col3", "col4", "col5", "col6", "col7"))
              )
# contenu base merge_4
knitr::kable( mat, digits = 2, caption = "Table: Nom des variables de la base *allgre.PB*")

```

### Constitution de la base *Déplacements*
```{r}
#    BASE DEPLACEMENTS
## exemple de calcul : nombre de trajets par déplacement
allgre.PB_V2$nbt2 <- ave( allgre.PB_V2$NO_TRAJ, allgre.PB_V2$id_depl, FUN = max)
addmargins( table(allgre.PB_V2$nbt2) )
## Réduction au déplacement : ATTENTION On ejecte les immobiles
allgreD <- distinct(allgre.PB_V2, id_depl, .keep_all = T)
  # ou avec subset(allgre.PB_V2, allgre.PB_V2$NO_TRAJ == allgre.PB_V2$ntraj )
# nb trajet
addmargins( table(allgreD$nbt2) )
# Par mode
table(allgreD$mode_depl_ag)
# durée
addmargins( table(allgre.PB_V2$duree))
table(is.na(allgreD$duree))
table(cut(allgreD$duree, breaks=seq(0, max(allgreD$duree, na.rm = T), 30)), useNA = "always")
# nb déplacements
table(allgre.PB_V2$nbd)

```

### Constitution de la base *Individus*

```{r}
############
#    BASE INDIVIDUS
## exemple de calcul : durée quotidienne des déplacements d'un individu
allgreD$btt2 <- ave( allgreD$duree, allgreD$id_pers, FUN = sum)
#addmargins( table(allgreD$btt2) )
## Reduction
allgreI <- distinct(allgreD, id_pers, .keep_all = T)
# subset(allgreD, allgreD$NO_DEPL == allgreD$nbd )
#addmargins( table(allgreI$btt2) )

summary(allgreI$btt); summary(allgreI$btt2)
addmargins( table(allgreI$nbd) )
table(is.na(allgreI$nbd))

```
Remarque: pour le calcul du temps quotidien de déplacement (BTT) les éléments *btt* et *btt2* diffèrent en raison de pré-traitement réalisés lors du calcul de *btt* (correction d'erreurs sur les horaires déclarés essentiellement)


### Constitution de la base *Ménages*

```{r}
############
#    BASE MENAGE
## exemple de calcul : taille du ménage et permis-ménage
allgreI$taillemng <- ave(allgreI$NO_PERS, allgreI$id_men, FUN = max)
allgreI$Permis_mng <- ave(allgreI$permis, allgreI$id_men, FUN = max)
addmargins( table(allgreI$taillemng) )
## Reduction
allgreM <- distinct(allgreI, id_men, .keep_all = T)
    #subset(allgreI, allgreI$NO_PERS == allgreI$taillemng )
addmargins( table(allgreM$taillemng) )
addmargins( table(allgreM$Permis_mng) )

table(allgreI$freqtcu)
table(allgreI$nbd)
table(allgreI$freqter)
```




# Re-définition des numéros zones :
```{r, message=FALSE}
allgre.PB_V2$"UN" <- as.numeric(allgre.PB_V2$nbd !=0)
table(as.numeric(allgre.PB_V2$UN))
allgre.PB_V2$DEST <- round(allgre.PB_V2$zonedest/1000)
head(allgre.PB_V2$DEST)
allgre.PB_V2$ORIG <- round(allgre.PB_V2$zoneorig/1000)
head(allgre.PB_V2$ORIG)
table(allgre.PB_V2$ORIG)
``` 




## Calcul des moyennes des distances parcourues
```{r}
mean(allgre.PB_V2$D12, na.rm = T); mean(allgre.PB_V2$D13, na.rm = T)
summary(allgre.PB_V2$D12)
# nombre de distance 'NA' par zone
table(allgre.PB_V2$zoneres.y[is.na(allgre.PB_V2$D12)==1])
tapply(allgre.PB_V2$D12, as.factor(allgre.PB_V2$zoneres.y),mean, na.rm = TRUE)

```
## Quelques définitions de variables

```{r}
## GRENOBLE 2010		 :
#######
table(allgre.PB_V2$OCCU1 )
allgre.PB_V2$statut2 <- factor(allgre.PB_V2$OCCU1 , 
                        labels=c("TRAVAIL A TEMPS PLEIN","TRAVAIL A TEMPS PARTIEL","FORMATION STAGE","ETUDIANT", "SCOLAIRE", "CHOMEUR","RETRAITE", "RESTE AU FOYER", "AUTRE"))
table(allgre.PB_V2$statut2)
#####
levels(allgre.PB_V2$statut2) <-  c("ACTIF","ACTIF", "ACTIF", "ETUDIANT", "SCOLAIRE", "CHOMEUR","RETRAITE", "RESTE AU FOYER", "AUTRE")
table(allgre.PB_V2$statut2)
#####
allgre.PB_V2$cspgroup <- trunc(allgre.PB_V2$csp / 10)
allgre.PB_V2$cspgroup[allgre.PB_V2$pcs %in% c(81,82)] <- 7
allgre.PB_V2$cspgroup[is.na(allgre.PB_V2$cspgroup)==T] <- 9
table(allgre.PB_V2$cspgroup)
```

***


# TEST SIG
```{r, eval=T}
# chargement des packages nécessaires
library(igraph)
library(dismo)
library(maptools)
library(reshape2)         # transformation format long, format large
library(sp)               # objets spatiaux
library(rgdal)            # fonctions de la bibliothèque GDAL
library(ggplot2)          # fonctions graphiques
#library(ggthemes)         # thèmes pour ggplot
library(grid)             # fonction arrow
library(cartography)      # cartographie thématique
library(RColorBrewer)     # palettes de couleurs de C. Brewer
library(dplyr) 
library(RgoogleMaps)
library(PBSmapping)
library(rgeos)
library(cleangeo)
library(devtools)
library(lwgeom)
```



```{r,  results='hide', message=FALSE, eval=F}
Sectir2010<-readOGR("FOND_MAP",layer="Sectir2010")
plot(Sectir2010)
# Affichage system de coordonnees
pathToShp <- "FOND_MAP"
Sectir2010@proj4string
ogrInfo(dsn = pathToShp,layer="Sectir2010")
```

### Import  du shp avec coordonnées compatibles
```{r, eval=T}
newESRI <- readOGR(dsn = "G:\\MyDATA\\TEst_Reunion_Distance\\FOND_MAP", layer = "NewESRI")


#ACADIA$data <- DF_Zone
plot(newESRI)
#plot(ACADIA)
```


## Le shapefile rencontre des erreurs (hole) qui sont corrigées par les outils `cleangeo()`
Il faut faire ce nettoyage *AVANT* le merge qui créée beaucoup de polygons

```{r, results='hide', message=FALSE, eval=TRUE}
################################## 
# https://gis.stackexchange.com/questions/113964/fixing-orphaned-holes-in-r
require(maptools)
# mysp <- readShapePoly("C:\\Users\\ijoly.INRA\\Desktop\\TEst_Reunion_Distance\\FOND_MAP\\Sectir2010.shp")
plot(newESRI, border= "lightgray")
require(devtools)
## to detect potential geometry issues
# devtools::install_github("eblondel/cleangeo")
require(cleangeo)
# exploration of sh
report <- clgeo_CollectionReport(newESRI)
clgeo_SummaryReport(report)
# cleaning
mysp.clean <- clgeo_Clean(newESRI)
# check
report.clean <- clgeo_CollectionReport(mysp.clean)
clgeo_SummaryReport(report.clean)
# geometry validity
require(rgeos)
sapply(slot(mysp.clean, "polygons"), function(x){
  gIsValid(SpatialPolygons(Srl = list(x)))
})


# ###################""
# # exploration of sh
# report <- clgeo_CollectionReport(mysp)
# clgeo_SummaryReport(report)
# # cleaning
# mysp.clean <- clgeo_Clean(mysp)
# # check
# report.clean <- clgeo_CollectionReport(mysp.clean)
# clgeo_SummaryReport(report.clean)
# # geometry validity
# require(rgeos)
# sapply(slot(mysp.clean, "polygons"), function(x){
#   gIsValid(SpatialPolygons(Srl = list(x)))
# })

```



# Calculs des indicateurs par zone : CARTE NBD BTT
```{r,  results='hide', message=FALSE, eval=T}
# Constitution de la base par zone
# allgre.PB$Maxnbd <- ave(allgre.PB$NO_DEPL,allgre.PB$ind, FUN = max)
# allgre.PB$BTT <- ave(allgre.PB$tps_trp,allgre.PB$ind, FUN = sum)
#table(allgre.PB$Maxnbd); summary(DF_Indiv$BTT)
#names(allgre.PB)
DF <- allgre.PB_V2[, c("nbd", "btt", "tir", "zoneres.x", "id_pers")]
# Calcul base individus des indicateurs individuels
DF_Indiv <- na.omit(subset(DF, allgre.PB_V2$NO_DEPL == allgre.PB_V2$nbd ))
addmargins(table(allgre.PB_V2$zoneres.x));addmargins(table(allgre.PB_V2$zoneres.y))
DF_Indiv$BTT_moy <- ave(DF_Indiv$btt,DF_Indiv$tir, FUN = mean)
DF_Indiv$BTT_med <- ave(na.omit(DF_Indiv$btt),DF_Indiv$tir, FUN = median)
DF_Indiv$nbd_med <- ave(DF_Indiv$nbd,DF_Indiv$tir, FUN = median)
DF_Indiv$nbd_moy <- ave(DF_Indiv$nbd,DF_Indiv$tir, FUN = mean)
DF_Indiv$Maxind <- ave(DF_Indiv$id_pers,DF_Indiv$tir, FUN = max)
# Réduction à la base Zone (avec le max(ind) par TIR)
DF_Zone <- subset(DF_Indiv, DF_Indiv$id_pers == DF_Indiv$Maxind, select =c(zoneres.x,BTT_med, BTT_moy, nbd_moy, nbd_med,tir))
``` 
### Jointure avec newESRI et data

```{r}
library(sp) # the trick is that this package must be loaded!
# JOINTURE avec option duplicateGEOM=T pour avoir autant de polygons que d'observations dans data
DF_Indiv$cod_sectir <- DF_Indiv$tir
newESRI_DF <- merge(mysp.clean, DF_Indiv, by = "cod_sectir", duplicateGeoms = TRUE)
PolyG <- SpatialPolygons(mysp.clean@polygons,proj4string=mysp.clean@proj4string)
```



# Cartographie Colorée 
```{r,  message=FALSE, eval=T}
choroLayer(spdf = newESRI_DF, df = newESRI_DF@data, var = "tir")
title("Cartographie de N° de Zone - pas très utile...")
```

# Import EMD :
```{r, message=FALSE, eval=T}
allgre.PB_V2$"UN" <- as.numeric(allgre.PB_V2$nbd !=0)
table(as.numeric(allgre.PB_V2$UN))
allgre.PB_V2$DEST <- round(allgre.PB_V2$zonedest/1000)
head(allgre.PB_V2$DEST)
allgre.PB_V2$ORIG <- round(allgre.PB_V2$zoneorig/1000)
head(allgre.PB_V2$ORIG)
``` 

Carte avec label: installer lwgeom
```{r}
choroLayer(spdf = newESRI_DF, df = newESRI_DF@data, var = "tir")
# Label plot of the Mean
labelLayer(spdf = newESRI_DF, df = newESRI_DF@data, txt = "tir", col = "#690409", cex = 0.9, font = 2, add=T)
```



# Le script suivant peut nécéssiter d'être  executer HORS MARKDOWN
```{r, echo=TRUE, eval=T}
Nclasse <- 5
########## Carte colorée
choroLayer(spdf = newESRI_DF, 
           df = DF_Zone,
           spdfid = "cod_sectir",
           dfid = "tir",
           var = "BTT_moy", 
           nclass = Nclasse,
           col = rev(brewer.pal(n = Nclasse, "RdYlBu")),
           legend.pos = "right", legend.frame = TRUE,
           legend.title.txt = "BTT moyens par zone")
########### Ajout de label : nbd par zone
# Label creation 
DF_Zone$lab <- paste(round(DF_Zone$nbd_moy,1), sep ="")
# Label plot of the Mean
#labelLayer(spdf = newESRI_DF, df = DF_Zone, txt = "lab", col = "#690409", cex = 0.9, font = 2, add=T)
####### Ajout d'éléments de présentations : Layout plot
layoutLayer(title = "BTT moyens par zone",
            sources = "EMD Grenoble 2010",
            author = "I. Joly",
            scale = 0,
            north = T,
            frame = TRUE,
            col = "black",
            coltitle = "white")
```


## Notre travail

```{r}
ggplot(data = allgreM, aes(x = nb_pers)) + geom_bar()
ggplot(data = allgreM, aes(x = VP_DISPO)) + geom_bar()
ggplot(data = allgreM, aes(x = Permis_mng)) + geom_bar()

allgreM$Permis_mng[allgreM$Permis_mng ==3] <- 1
allgreM[121] <- allgreM$VP_DISPO
allgreM$V121[allgreM$V121 >0] <- 1
table(allgreM$V121)
names(allgreM)[names(allgreM) == "V121"] <- "motorisation"
```
